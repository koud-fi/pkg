package pk

import (
	"bytes"
	"database/sql/driver"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"math/bits"
	"time"
)

const (
	tidCounterBits   = 10
	tidCounterOffset = 0
	tidCounterMax    = 1 << tidCounterBits
	tidNumberBits    = 13
	tidNumberOffset  = tidCounterBits
	tidNumberMax     = 1 << tidNumberBits
	tidTimeOffset    = tidCounterBits + tidNumberBits
	tidTimeMax       = 1 << tidTimeBits
	tidTimeBits      = 63 - tidTimeOffset

	tidTimeStep = int64(1 << tidTimeOffset)

	MaxTIDSerialN     = tidCounterMax - 1
	MaxTIDSerialBatch = tidTimeMax - 1
)

// TID is an 63-bit "temporal" ID that is generated from current time and a magic numbers.
type TID struct {
	ts int64 // Underlying "time step", or user defined number of n is zero
	n  int32 // User defined number, zero for serial numbers, non-zero for time based IDs
	c  int32 // Counter in the current "time step"
	v  bool  // Virtual ID flag
}

func NewTID(now time.Time, n, c uint, virtual bool) TID {
	if n == 0 || n >= tidNumberMax {
		panic(fmt.Sprintf("invalid 'n' for TID, must be greater than 0 and less than %d",
			tidNumberMax))
	}
	if c >= tidCounterMax {
		panic(fmt.Sprintf("invalid 'c' for TID, must be less than %d", tidCounterMax))
	}
	return TID{
		ts: now.UnixNano() / tidTimeStep,
		n:  int32(n),
		c:  int32(c),
		v:  virtual,
	}
}

func NewSerialTID(batch uint64, n uint) TID {
	if batch == 0 || batch > MaxTIDSerialBatch {
		panic(fmt.Sprintf("invalid 'batch' for serial TID, must be >0 and <=%d",
			MaxTIDSerialBatch))
	}
	if n > MaxTIDSerialN {
		panic(fmt.Sprintf("invalid 'n' for serial TID, must be <=%d", MaxTIDSerialN))
	}
	return TID{
		ts: int64(batch),
		n:  0,
		c:  int32(n),
		v:  false,
	}
}

func NewRawValueTID(v int64) (t TID) {
	t.ApplyRawValue(v)
	return t
}

// ParseTID converts string generated by the TIDs String function into a TID.
func ParseTID(s string) (TID, error) {
	return ParseTIDBytes([]byte(s))
}

// ParseTIDBytes converts raw bytes into a TID.
func ParseTIDBytes(raw []byte) (TID, error) {
	var b [8]byte
	n, err := base64.RawURLEncoding.Decode(b[:], bytes.Trim(raw, `"`))
	if err != nil {
		return TID{}, fmt.Errorf("tid: decode: %w", err)
	}
	switch {
	case n > 8:
		return TID{}, fmt.Errorf("tid: invalid length")
	case n < 8:
		// Shift bytes to end and pad with leading zeros
		copy(b[8-n:], b[:n])
		for i := range 8 - n {
			b[i] = 0
		}
	}
	return NewRawValueTID(int64(binary.BigEndian.Uint64(b[:]))), nil
}

func (t *TID) ApplyRawValue(v int64) {
	if v < 0 {
		t.v = true
		v = -v
	}
	t.c = int32(unpack(uint64(v), tidCounterOffset, tidCounterBits))
	t.n = int32(unpack(uint64(v), tidNumberOffset, tidNumberBits))
	t.ts = int64(unpack(uint64(v), tidTimeOffset, tidTimeBits))
}

func (t TID) RawValue() int64 {
	var v uint64
	v = pack(v, tidCounterOffset, tidCounterBits, uint64(t.c))
	v = pack(v, tidNumberOffset, tidNumberBits, uint64(t.n))
	v = pack(v, tidTimeOffset, tidTimeBits, uint64(t.ts))
	if t.v {
		v |= (1 << 63)
	}
	return int64(v)
}

func (t TID) Time() time.Time {
	const sec = int64(time.Second)
	if t.n == 0 {
		panic("can't extract time from TID with 'n' of 0")
	}
	v := t.RawValue()
	if t.IsVirtual() {
		v = -v
	}
	s := v / sec
	n := v % sec
	return time.Unix(s, n)
}

func (t TID) Serial() int64 {
	if t.IsVirtual() {
		panic("can't extract serial from a virtual TID")
	}
	if t.n != 0 {
		panic("can't extract serial from TID with 'n' of >0")
	}
	return t.ts*(1<<tidCounterBits) + int64(t.c)
}

func (t TID) IsVirtual() bool { return t.v }

func (t TID) IsZero() bool {
	return t.ts == 0 && t.n == 0 && t.c == 0
}

func (t TID) String() string {
	b := t.Bytes()

	// Find first non-zero byte to avoid encoding leading zeros
	i := 0
	for i < len(b) && b[i] == 0 {
		i++
	}
	return base64.RawURLEncoding.EncodeToString(b[i:])
}

func (t TID) Bytes() []byte {
	var b [8]byte
	binary.BigEndian.PutUint64(b[:], uint64(t.RawValue()))

	// TODO: apply feistel encoding

	return b[:]
}

// Value implements the sql.Valuer interface.
func (t TID) Value() (driver.Value, error) {
	return t.RawValue(), nil
}

// Scan implements the sql.Scanner interface.
func (t *TID) Scan(value any) error {
	v, ok := value.(int64)
	if !ok {
		return fmt.Errorf("TID.Scan: invalid type %T, expected int64", value)
	}
	t.ApplyRawValue(v)
	return nil
}

// MarshalJSON implements the json.Marshaler interface.
func (t TID) MarshalJSON() ([]byte, error) {
	return []byte(`"` + t.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (t *TID) UnmarshalJSON(b []byte) error {
	tid, err := ParseTIDBytes(b)
	if err != nil {
		return fmt.Errorf("tid: unmarshal: %w", err)
	}
	*t = tid
	return nil
}

// pack writes the lower `size` bits of `value` into `dst` starting at bit `index`.
// It panics if size == 0, index+size > 64, or value needs more than `size` bits.
func pack(dst uint64, index, size uint, value uint64) uint64 {
	if size == 0 || index+size > 64 {
		panic(fmt.Sprintf("bitpack: invalid bit range index=%d size=%d", index, size))
	}
	if bits.Len64(value) > int(size) {
		panic(fmt.Sprintf("bitpack: value %d does not fit in %d bits", value, size))
	}
	mask := ((uint64(1) << size) - 1) << index
	dst &^= mask
	dst |= (value << index) & mask
	return dst
}

// unpack extracts `size` bits from `src` starting at bit `index`.
// It panics if size == 0 or index+size > 64.
func unpack(src uint64, index, size uint) uint64 {
	if size == 0 || index+size > 64 {
		panic(fmt.Sprintf("bitpack: invalid bit range index=%d size=%d", index, size))
	}
	mask := ((uint64(1) << size) - 1) << index
	return (src & mask) >> index
}
