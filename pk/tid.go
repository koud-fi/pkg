package pk

import (
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"sync"
	"time"
)

const tidTimeStep = int64(time.Millisecond)

// TID is an 63-bit "temporal" ID that is generated from current time and a magic number.
// 1 million new TIDs can be generated each millisecond, they will run out around year 2262.
type TID int64

// New creates a TID from given time and number, N must be a positive integer under 1 million.
func NewTID(now time.Time, n uint) TID {
	return newTID(now.UTC().UnixNano()/tidTimeStep, int64(n))
}

func newTID(ts, n int64) TID {
	if n < 0 || n >= tidTimeStep {
		panic("tid: invalid 'n' for TID")
	}
	return TID(ts*tidTimeStep + n)
}

// ParseTID converts string generated by the TIDs String function into a TID.
func ParseTID(s string) (TID, error) {
	return ParseTIDBytes([]byte(s))
}

// ParseTIDBytes converts raw bytes into a TID.
func ParseTIDBytes(raw []byte) (TID, error) {
	var b [8]byte
	n, err := base64.RawURLEncoding.Decode(b[:], raw)
	if err != nil {
		return 0, fmt.Errorf("tid: %w", err)
	}
	switch {
	case n > 8:
		return 0, fmt.Errorf("tid: invalid length")
	case n < 8:
		// Shift bytes to end and pad with leading zeros
		copy(b[8-n:], b[:n])
		for i := range 8 - n {
			b[i] = 0
		}
	}
	return TID(binary.BigEndian.Uint64(b[:])), nil
}

// Time converts TID into a unique time.Time with millisecond precision,
// the micro/nanosecond part is effectively noise.
func (t TID) Time() time.Time {
	s := int64(t) / int64(time.Second)
	n := int64(t) % int64(time.Second)
	return time.Unix(s, n)
}

// Int64 is just a cast from TID to int64.
func (t TID) Int64() int64 { return int64(t) }

// String converts TID to a base-64 string.
func (t TID) String() string {
	var b [8]byte
	binary.BigEndian.PutUint64(b[:], uint64(t))

	// Find first non-zero byte to avoid encoding leading zeros
	i := 0
	for i < len(b) && b[i] == 0 {
		i++
	}
	return base64.RawURLEncoding.EncodeToString(b[i:])
}

func (t TID) MarshalJSON() ([]byte, error) {
	return []byte(`"` + t.String() + `"`), nil
}

func (t *TID) UnmarshalJSON(b []byte) error {
	tid, err := ParseTIDBytes(b)
	if err != nil {
		return err
	}
	*t = tid
	return nil
}

type TIDSource struct {
	mu sync.Mutex
	ts int64
	n  int

	// TODO: support for node ID
}

func NewTIDSource(now time.Time) *TIDSource {
	return &TIDSource{
		ts: now.UTC().UnixNano() / tidTimeStep,
		n:  1000,
	}
}

func (t *TIDSource) Next(now time.Time) TID {
	t.mu.Lock()
	defer t.mu.Unlock()

	nowTs := now.UTC().UnixNano() / int64(time.Millisecond)
	if nowTs <= t.ts {
		if t.n == 1000 {
			t.ts++
			time.Sleep(time.Duration((t.ts - nowTs) * tidTimeStep))
			t.n = 1
		} else {
			t.n++
		}
	} else {
		t.ts = nowTs
		t.n = 1
	}
	return newTID(t.ts, int64(t.n-1)*1000)
}
